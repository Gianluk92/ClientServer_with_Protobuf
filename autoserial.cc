/* !----- THIS IS AN AUTOGENERATED CODE DON'T MODIFY -------! */

#include "autoserial.hh"

void err::warning_err(const char * string, int errnumb) 
{
    if(verbosity)
        cout<<string<<" "<<strerror(errnumb)<<endl;
    log<<string<<" "<<strerror(errnumb)<<endl;
    log.flush();
}

void err::exit_err(const char * string, int errnumb) 
{
    if(verbosity)
        cout<<string<<" "<<strerror(errnumb)<<endl;
    log<<string<<" "<<strerror(errnumb)<<endl;
    exit(EXIT_FAILURE);
}

err::err(const char* namefile, bool verbosity)
{
    system("mkdir -p ./log");
    this->namefile = "./log/" + std::string(namefile);
    cout<<namefile<<endl;
    this->verbosity = verbosity;
    log.open(namefile,std::ofstream::app);
}

int server::server_init()
{
    int fd_s;
    struct sockaddr_in myserver;

    opt = SO_REUSEADDR;

    bzero(&myserver, sizeof(myserver));
    myserver.sin_family = AF_INET;                // host byte order
    myserver.sin_port = htons(port);              // short, network byte order
    myserver.sin_addr.s_addr = htonl(INADDR_ANY); // automatically fill with my IP

    if ((fd_s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        log_file-> exit_err("socket",errno);
    }
    log_file-> warning_err("socket",errno);
    if (setsockopt(fd_s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {
        log_file-> exit_err("set socket",errno);
    }
    log_file-> warning_err("set socket",errno);
    if (bind(fd_s, (struct sockaddr *)&myserver, sizeof(struct sockaddr)) == -1) {
        log_file-> exit_err("bind",errno);
    }
    log_file-> warning_err("bind",errno);
    if (listen(fd_s, 10) == -1) {
        log_file-> exit_err("listen",errno);
    }
    log_file-> warning_err("listen",errno);
    general_descriptor = fd_s;
    return fd_s;
}

int server::server_accept(int fd_s)
{
    socklen_t sin_size = sizeof(struct sockaddr_in);
    if((session_descriptor = accept(fd_s, (struct sockaddr *)&client, &sin_size))==-1);
        log_file-> warning_err("session accept",errno);
    log_file-> warning_err("session accept",errno);
    return session_descriptor;
}

void server::accept_close(int fd_s)
{
    if(close(fd_s)==-1){
        log_file-> warning_err("session close",errno);
    }
    log_file-> warning_err("session close",errno);
}

void server::server_close()
{
    if(close(general_descriptor)==-1){
        log_file-> exit_err("server close",errno);
    }
    log_file-> warning_err("server close",errno);
}

int autoserial::mysend(int fd, void* buf, int size, err* log_file)
{   
    size_t len = size;
    int size_tot = 0, send_size;

    if((send_size = send(fd, &size, sizeof(size), MSG_NOSIGNAL)) <= 0)
    {
        if(send_size == -1) 
           log_file-> warning_err("send error",errno);
        return 0;
    }

    while(len > 0)
    {
        if((send_size = send(fd, buf, len, MSG_NOSIGNAL)) <= 0)
        {
            if(send_size == -1) 
                log_file-> warning_err("send error",errno);
            return 0;
        }
        len -= send_size;
        size_tot += send_size;
    }
    return size_tot;
}

int autoserial::receive(int fd, void* buf, err* log_file)
{
    int size, size_tot=0, recv_size;
    size_t len;
    
    if((recv_size = recv(fd, &size, sizeof(int), 0)) <= 0)
    {
        if(recv_size == -1) 
            log_file-> warning_err("receive",errno);
        return 0;
    }
    len = size;

    while(len > 0)
    {
        if((recv_size = recv(fd, buf, len, 0)) <= 0){
            if(recv_size == -1) 
                log_file-> warning_err("receive",errno);
            return 0;
        }
        len -= recv_size;
        size_tot += recv_size;
    }
    return size_tot;
}


client::client(){
    std::string str = HOSTNAME ;
    hostname = new char[str.size() + 1];
    std::copy(str.begin(), str.end(), hostname);
    hostname[str.size()] = '\0'; 
    port = PORT;
}

client::client(char* hname, char* p){
    hostname = hname;
    port = atoi(p);
}

int client::client_init()
{
    int fd;
    if ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        log_file-> exit_err("socket",errno);
    }
    log_file-> warning_err("socket",errno);
    general_descriptor = fd;
    return fd;
}

void client::client_connect(int fd)
{

    if ((he = gethostbyname(hostname)) == NULL) {
        log_file-> exit_err("error host name",errno);
    }
    log_file-> warning_err("host name",errno);
    bzero(&myserver, sizeof(myserver));
    myserver.sin_family = AF_INET;
    myserver.sin_port = htons(port);
    myserver.sin_addr = *((struct in_addr *)he->h_addr);
    if (connect(fd, (struct sockaddr *)&myserver, sizeof(struct sockaddr)) == -1) {
       log_file-> exit_err("session connect",errno);
    }
    log_file-> warning_err("session connect",errno);
}

void client::client_close()
{
    if(close(general_descriptor)==-1){
        log_file-> exit_err("connect",errno);
    }
    log_file-> warning_err("connect",errno);

}

//function client
--function--

void server::request_handler()
{
    string msg;
    char nameF[20];

    while(receive(session_descriptor, nameF, log_file) != 0)
    {   
        int c = atoi(nameF);

        switch(c){

            //function server
            --function_switch--

            default:
                cout<< "Non esiste questa funzione"<<endl;
        }
    }
}