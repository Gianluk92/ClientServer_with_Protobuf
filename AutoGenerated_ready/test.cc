/* !----- THIS IS AN AUTOGENERATED CODE DON'T MODIFY -------! */

#include "test.hh"

void err::warning_err(const char * string, int errnumb) 
{
    if(verbosity)
        cout<<string<<" "<<strerror(errnumb)<<endl;
    log<<string<<" "<<strerror(errnumb)<<endl;
    log.flush();
}

void err::exit_err(const char * string, int errnumb) 
{
    if(verbosity)
        cout<<string<<" "<<strerror(errnumb)<<endl;
    log<<string<<" "<<strerror(errnumb)<<endl;
    exit(EXIT_FAILURE);
}

err::err(const char* namefile, bool verbosity)
{
    system("mkdir -p ./log");
    this->namefile = "./log/" + std::string(namefile);
    cout<<namefile<<endl;
    this->verbosity = verbosity;
    log.open(namefile,std::ofstream::app);
}

int server::server_init()
{
    int fd_s;
    struct sockaddr_in myserver;

    opt = SO_REUSEADDR;

    bzero(&myserver, sizeof(myserver));
    myserver.sin_family = AF_INET;                // host byte order
    myserver.sin_port = htons(port);              // short, network byte order
    myserver.sin_addr.s_addr = htonl(INADDR_ANY); // automatically fill with my IP

    if ((fd_s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        log_file-> exit_err("socket",errno);
    }
    log_file-> warning_err("socket",errno);
    if (setsockopt(fd_s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {
        log_file-> exit_err("set socket",errno);
    }
    log_file-> warning_err("set socket",errno);
    if (bind(fd_s, (struct sockaddr *)&myserver, sizeof(struct sockaddr)) == -1) {
        log_file-> exit_err("bind",errno);
    }
    log_file-> warning_err("bind",errno);
    if (listen(fd_s, 10) == -1) {
        log_file-> exit_err("listen",errno);
    }
    log_file-> warning_err("listen",errno);
    general_descriptor = fd_s;
    return fd_s;
}

int server::server_accept(int fd_s)
{
    socklen_t sin_size = sizeof(struct sockaddr_in);
    if((session_descriptor = accept(fd_s, (struct sockaddr *)&client, &sin_size))==-1);
        log_file-> warning_err("session accept",errno);
    log_file-> warning_err("session accept",errno);
    return session_descriptor;
}

void server::accept_close(int fd_s)
{
    if(close(fd_s)==-1){
        log_file-> warning_err("session close",errno);
    }
    log_file-> warning_err("session close",errno);
}

void server::server_close()
{
    if(close(general_descriptor)==-1){
        log_file-> exit_err("server close",errno);
    }
    log_file-> warning_err("server close",errno);
}

int test::mysend(int fd, void* buf, int size, err* log_file)
{   
    size_t len = size;
    int size_tot = 0, send_size;

    if((send_size = send(fd, &size, sizeof(size), MSG_NOSIGNAL)) <= 0)
    {
        if(send_size == -1) 
           log_file-> warning_err("send error",errno);
        return 0;
    }

    while(len > 0)
    {
        if((send_size = send(fd, buf, len, MSG_NOSIGNAL)) <= 0)
        {
            if(send_size == -1) 
                log_file-> warning_err("send error",errno);
            return 0;
        }
        len -= send_size;
        size_tot += send_size;
    }
    return size_tot;
}

int test::receive(int fd, void* buf, err* log_file)
{
    int size, size_tot=0, recv_size;
    size_t len;
    
    if((recv_size = recv(fd, &size, sizeof(int), 0)) <= 0)
    {
        if(recv_size == -1) 
            log_file-> warning_err("receive",errno);
        return 0;
    }
    len = size;

    while(len > 0)
    {
        if((recv_size = recv(fd, buf, len, 0)) <= 0){
            if(recv_size == -1) 
                log_file-> warning_err("receive",errno);
            return 0;
        }
        len -= recv_size;
        size_tot += recv_size;
    }
    return size_tot;
}


client::client(){
    std::string str = HOSTNAME ;
    hostname = new char[str.size() + 1];
    std::copy(str.begin(), str.end(), hostname);
    hostname[str.size()] = '\0'; 
    port = PORT;
}

client::client(char* hname, char* p){
    hostname = hname;
    port = atoi(p);
}

int client::client_init()
{
    int fd;
    if ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        log_file-> exit_err("socket",errno);
    }
    log_file-> warning_err("socket",errno);
    general_descriptor = fd;
    return fd;
}

void client::client_connect(int fd)
{

    if ((he = gethostbyname(hostname)) == NULL) {
        log_file-> exit_err("error host name",errno);
    }
    log_file-> warning_err("host name",errno);
    bzero(&myserver, sizeof(myserver));
    myserver.sin_family = AF_INET;
    myserver.sin_port = htons(port);
    myserver.sin_addr = *((struct in_addr *)he->h_addr);
    if (connect(fd, (struct sockaddr *)&myserver, sizeof(struct sockaddr)) == -1) {
       log_file-> exit_err("session connect",errno);
    }
    log_file-> warning_err("session connect",errno);
}

void client::client_close()
{
    if(close(general_descriptor)==-1){
        log_file-> exit_err("connect",errno);
    }
    log_file-> warning_err("connect",errno);

}

//function client
myproto client::sum( myproto num1, myproto num2)
{ 
	m_sum proto_msg; 
    string msg; 
    char nameF[20]; 
    fun selector = f_sum; 
    msg = std::to_string(selector); 
    sprintf(nameF,"%s",msg.c_str()); 
    mysend(general_descriptor, nameF, sizeof(nameF), log_file); 
    	proto_msg.mutable_num1()->CopyFrom(num1);
	proto_msg.mutable_num2()->CopyFrom(num2);
     proto_msg.clear_response(); 
    proto_msg.SerializeToString(&msg); 
    sprintf(buf,"%s",msg.c_str()); 
    mysend(general_descriptor,buf, sizeof(buf), log_file); 
    int num_bytes = receive(general_descriptor, buf, log_file); 
    buf[num_bytes] = '\0'; 
    msg = buf; 
    proto_msg.ParseFromString(msg); 
    log_file-> warning_err("function sum end",errno); 
    return proto_msg.response(); 
} 

int client::prod( int num1, int num2)
{ 
	m_prod proto_msg; 
    string msg; 
    char nameF[20]; 
    fun selector = f_prod; 
    msg = std::to_string(selector); 
    sprintf(nameF,"%s",msg.c_str()); 
    mysend(general_descriptor, nameF, sizeof(nameF), log_file); 
    	proto_msg.set_num1(num1);
	proto_msg.set_num2(num2);
     proto_msg.clear_response(); 
    proto_msg.SerializeToString(&msg); 
    sprintf(buf,"%s",msg.c_str()); 
    mysend(general_descriptor,buf, sizeof(buf), log_file); 
    int num_bytes = receive(general_descriptor, buf, log_file); 
    buf[num_bytes] = '\0'; 
    msg = buf; 
    proto_msg.ParseFromString(msg); 
    log_file-> warning_err("function prod end",errno); 
    return proto_msg.response(); 
} 



void server::request_handler()
{
    string msg;
    char nameF[20];

    while(receive(session_descriptor, nameF, log_file) != 0)
    {   
        int c = atoi(nameF);

        switch(c){

            //function server
            
			case f_sum: 
			{
	    		m_sum proto_msg; 
	    		int num_bytes = receive(session_descriptor, buf, log_file); 
	    		buf[num_bytes] = '\0'; 
	    		msg = buf; 
	    		proto_msg.ParseFromString(msg);
	    		myproto r = sum(proto_msg.num1(),proto_msg.num2());
				proto_msg.mutable_response()->CopyFrom(r);
				proto_msg.clear_num1();
				proto_msg.clear_num2(); 
	    		proto_msg.SerializeToString(&msg);
	    		sprintf(buf,"%s",msg.c_str()); 
	    		mysend(session_descriptor,buf, sizeof(buf), log_file);
    			log_file-> warning_err("function sum end",errno); 
	    		break;
			}


			case f_prod: 
			{
	    		m_prod proto_msg; 
	    		int num_bytes = receive(session_descriptor, buf, log_file); 
	    		buf[num_bytes] = '\0'; 
	    		msg = buf; 
	    		proto_msg.ParseFromString(msg);
	    		int r = prod(proto_msg.num1(),proto_msg.num2());
				proto_msg.set_response(r);
				proto_msg.clear_num1();
				proto_msg.clear_num2(); 
	    		proto_msg.SerializeToString(&msg);
	    		sprintf(buf,"%s",msg.c_str()); 
	    		mysend(session_descriptor,buf, sizeof(buf), log_file);
    			log_file-> warning_err("function prod end",errno); 
	    		break;
			}



            default:
                cout<< "Non esiste questa funzione"<<endl;
        }
    }
}
